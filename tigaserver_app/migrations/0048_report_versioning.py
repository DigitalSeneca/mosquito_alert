# Generated by Django 2.2.7 on 2024-01-24 15:33

import uuid
from tqdm import tqdm

import django.contrib.gis.db.models.fields
from django.db import migrations, models, transaction
from django.db.models import OuterRef, Subquery
from django.db.utils import IntegrityError
import django.db.models.deletion

import simple_history.models


def get_models_with_foreign_key_to(apps, model):
    """
    Returns a list of tuples containing models that have a ForeignKey
    relationship to the specified model, along with the field name
    of the ForeignKey.

    Parameters:
    - model: The model class to check for ForeignKey references.

    Returns:
    - List of tuples where each tuple contains a model class and
      the field name of the ForeignKey relationship.
    """
    models_with_foreign_key = []

    # Iterate through all installed app configurations
    for app_config in apps.get_app_configs():
        # Iterate through all models in the app configuration
        for model_class in app_config.get_models():
            # Iterate through the fields of the model
            for field in model_class._meta.fields:
                # Check if the field is a ForeignKey and references the specified model
                if isinstance(field, models.ForeignKey) and field.remote_field.model == model:
                    # Add a tuple containing the model class and field name to the list
                    models_with_foreign_key.append((model_class, field.name))

    return models_with_foreign_key

def populate_report_history_table(apps, schema_editor):
    # Loading models
    Report = apps.get_model("tigaserver_app", "Report")
    HistoricalReport = apps.get_model("tigaserver_app", "HistoricalReport")
    Photo = apps.get_model("tigaserver_app", "Photo")
    CrowdcraftingTask = apps.get_model("tigacrafting", "CrowdcraftingTask")

    # First version of the reports (lowest version_number)
    version_subquery = Report.objects.filter(
        user=OuterRef('user'), 
        report_id=OuterRef('report_id'), 
        type=OuterRef('type')
    )
    lowest_version_reports_subquery = version_subquery.exclude(version_number=-1).order_by('version_number', 'server_upload_time')
    lowest_version_reports = lowest_version_reports_subquery.values('pk')[:1]

    latest_version_reports_subquery = version_subquery.order_by('-version_number', '-server_upload_time')
    latest_version_reports = latest_version_reports_subquery.values('pk')[:1]

    # NOTE: There are cases where only two objects with version_number = -1 are present.
    #       Setting temporally the first of those to version_number = 0
    Report.objects.filter(
        # Get those reports considered lowest version (allow version_number = -1 too)
        pk__in=Subquery(version_subquery.order_by('version_number', 'server_upload_time').values('pk')[:1])
    ).annotate(
        latest_version=Subquery(latest_version_reports_subquery.values('version_number')[:1]),
        latest_pk=Subquery(latest_version_reports)
    ).filter(
        # Both last version found and current is version_number = -1
        version_number=-1,
        latest_version=-1
    ).exclude(
        # The latest version and lowest version is not the same.
        # There are cases where only 1 report with version_number = -1
        # is found...
        pk=models.F('latest_pk')
    ).update(
        version_number=0
    )

    histories = []
    original_reports_qs = Report.objects.filter(pk__in=Subquery(lowest_version_reports))
    for original_report in tqdm(original_reports_qs.annotate(latest_pk=Subquery(latest_version_reports)).select_related('user').iterator(), total=original_reports_qs.count(), desc=f"Creating first {Report._meta.verbose_name_plural} versions", unit=str(Report._meta.verbose_name_plural)):
        report_versionable_kwargs = {
            field.attname: getattr(original_report, field.attname)
            for field in HistoricalReport._meta.fields
            if hasattr(original_report, field.attname)
        }
        report_versionable_kwargs[Report._meta.pk.name] = original_report.latest_pk

        # Create first history object
        histories.append(
            HistoricalReport(
                #history_id=original_report.pk,
                history_date=original_report.server_upload_time,
                history_type="+", # Create
                history_user=original_report.user,
                **report_versionable_kwargs
            )
        )

    edited_reports_qs = Report.objects.exclude(pk__in=Subquery(lowest_version_reports))
    for edited_report in tqdm(edited_reports_qs.annotate(latest_pk=Subquery(latest_version_reports)).select_related('user').iterator(), total=edited_reports_qs.count(), desc=f"Creating updated {Report._meta.verbose_name_plural} versions", unit=str(Report._meta.verbose_name_plural)):
        report_versionable_kwargs = {
            field.attname: getattr(edited_report, field.attname)
            for field in HistoricalReport._meta.fields
            if hasattr(edited_report, field.attname)
        }
        report_versionable_kwargs[Report._meta.pk.name] = edited_report.latest_pk

        # Create history modification of the reports
        # NOTE: There are cases from old versions where only 1 report is found with version_number = -1
        #       So, we will generate a CREATED history for them, and after it will set as delted.
        is_single_deleted_report = edited_report.version_number == -1 and edited_report.pk == edited_report.latest_pk
        if is_single_deleted_report or edited_report.version_number != -1:
            histories.append(
                HistoricalReport(
                    history_id=None if is_single_deleted_report else edited_report.pk,
                    history_date=edited_report.server_upload_time,
                    history_type="+" if is_single_deleted_report else "~", # Update
                    history_user=edited_report.user,
                    **report_versionable_kwargs
                )
            )

    print("Inserting history objects into the DB.")
    HistoricalReport.objects.bulk_create(histories, batch_size=4000)

    report_to_delete_qs = Report.objects.exclude(pk__in=Subquery(latest_version_reports))
    # Need to get all pks here to ensure any of the following queries do not
    # modify de result for the reports to be deleted.
    report_to_delete_pk = list(report_to_delete_qs.all().values_list('pk', flat=True))
    # Update any FK that uses reports that are going to be deleted.
    related_models = get_models_with_foreign_key_to(apps, Report)
    # We don't want to update these ones, but delete them.
    excluded_models = [
        Photo,
        apps.get_model("tigaserver_app", "ReportResponse"),
        apps.get_model("tigaserver_app", "IAScore")
    ]
    for object_to_delete in tqdm(report_to_delete_qs.annotate(latest_pk=Subquery(latest_version_reports)).iterator(), total=report_to_delete_qs.count(), desc=f"Update old FKs references"):
        for related_model, related_fieldname in related_models:
            if related_model in excluded_models:
                continue

            # Try updating to the new report pk
            # If any error (such as unique toger) -> delete.
            # There is an exception with ExpertReportAnnotation. which we
            # don't want to remove, only keep the latest modified in case
            # of duplicate. This is not easy to do here, so its unique
            # constraint for field (user, report) has been temporally disabled
            # and will treat duplicated after this migrations. Here they're
            # just copied.
            #     See migrations:
            #           ('tigacrafting', '0020_auto_20240125_1557')
            #           ('tigacrafting', '0021_auto_20240125_1557')
            try:
                with transaction.atomic():
                    related_model.objects.filter(**{related_fieldname: object_to_delete}).update(**{related_fieldname + "_id": object_to_delete.latest_pk})
            except IntegrityError:
                # Case unique constraint.
                related_model.objects.filter(**{related_fieldname: object_to_delete}).delete()

    print("Ensuring the version kept contains images (if ever had)")
    report_without_photo_qs = Report.objects.filter(
        pk__in=Subquery(latest_version_reports), 
        photos__isnull=True
    ).annotate(
        last_version_with_photo_pk=Subquery(
            latest_version_reports_subquery.filter(photos__isnull=False).values('pk')[:1]
        )
    ).filter(last_version_with_photo_pk__isnull=False)
    for report_without_photo in report_without_photo_qs.iterator():
        Photo.objects.filter(report__pk=report_without_photo.last_version_with_photo_pk).update(report=report_without_photo)

    # NOTE: needed to avoid on_delete=PROTECT
    CrowdcraftingTask.objects.filter(photo__report__pk__in=report_to_delete_pk).delete()

    print("Setting information to the final report version.")
    # Set deleted_at if the report has been deleted
    Report.objects.filter(
        pk__in=Subquery(latest_version_reports)
    ).update(
        deleted_at=Subquery(
            latest_version_reports_subquery.filter(version_number=-1).values('server_upload_time')[:1],
            output_field=models.DateTimeField()
        )
    )

    # Setting timming info from the original report
    Report.objects.filter(
        pk__in=Subquery(latest_version_reports)
    ).exclude(
        version_number=-1 # NOTE: filter those which last version is -1 (keep timming info).
    ).update(
        server_upload_time=Subquery(
            lowest_version_reports_subquery.values('server_upload_time')[:1],
            output_field=models.DateTimeField()
        ),
        phone_upload_time=Subquery(
            lowest_version_reports_subquery.values('phone_upload_time')[:1],
            output_field=models.DateTimeField()
        ),
        creation_time=Subquery(
            lowest_version_reports_subquery.values('creation_time')[:1],
            output_field=models.DateTimeField()
        )
    )

    print("Deleting report versions from the Report table (already in the history table).")
    print(Report.objects.filter(pk__in=report_to_delete_pk).delete())

    # Setting version_number not to break any pipeline.
    print("Adjusting new version_number to all reports.")
    Report.objects.filter(deleted_at__isnull=True).update(version_number=0)

    # But set the ones now marked as deleted with version_number=-1
    Report.objects.filter(deleted_at__isnull=False).update(version_number=-1)


class Migration(migrations.Migration):

    dependencies = [
        ('tigaserver_app', '0047_populate_responses_column'),
        ('tigacrafting', '0020_auto_20240125_1557'),
    ]

    operations = [
        migrations.AddField(
            model_name='report',
            name='deleted_at',
            field=models.DateTimeField(null=True, blank=True, editable=False, default=None),
        ),
        migrations.AlterField(
            model_name='report',
            name='version_number',
            field=models.SmallIntegerField(db_index=True, default=0, help_text='-1 if deleted, otherwise 0.'),
        ),
        migrations.CreateModel(
            name='HistoricalReport',
            fields=[
                ('version_UUID', models.CharField(db_index=True, help_text='UUID randomly generated on phone to identify each unique report version. Must be exactly 36 characters (32 hex digits plus 4 hyphens).', max_length=36)),
                ('report_id', models.CharField(db_index=True, help_text='4-digit alpha-numeric code generated on user phone to identify each unique report from that user. Digits should lbe randomly drawn from the set of all lowercase and uppercase alphabetic characters and 0-9, but excluding 0, o, and O to avoid confusion if we ever need user to be able to refer to a report ID in correspondence with MoveLab (as was previously the case when we had them sending samples).', max_length=4)),
                ('creation_time', models.DateTimeField(help_text="Date and time on phone when first version of report was created. Format as ECMA 262 date time string (e.g. '2014-05-17T12:34:56.123+01:00'.")),
                ('type', models.CharField(choices=[('bite', 'Bite'), ('adult', 'Adult'), ('site', 'Breeding Site'), ('mission', 'Mission')], help_text="Type of report: 'adult', 'site', or 'mission'.", max_length=7)),
                ('location_choice', models.CharField(choices=[('current', "Current location detected by user's device"), ('selected', 'Location selected by user from map'), ('missing', 'No location choice submitted - should be used only for missions')], help_text="Did user indicate that report relates to current location of phone ('current') or to a location selected manually on the map ('selected')? Or is the choice missing ('missing')", max_length=8)),
                ('current_location_lon', models.FloatField(blank=True, help_text="Longitude of user's current location. In decimal degrees.", null=True)),
                ('current_location_lat', models.FloatField(blank=True, help_text="Latitude of user's current location. In decimal degrees.", null=True)),
                ('selected_location_lon', models.FloatField(blank=True, help_text='Latitude of location selected by user on map. In decimal degrees.', null=True)),
                ('selected_location_lat', models.FloatField(blank=True, help_text='Longitude of location selected by user on map. In decimal degrees.', null=True)),
                ('point', django.contrib.gis.db.models.fields.PointField(blank=True, null=True, srid=4326)),
                ('note', models.TextField(blank=True, help_text='Note user attached to report.', null=True)),
                ('nuts_2', models.CharField(blank=True, max_length=4, null=True)),
                ('nuts_3', models.CharField(blank=True, max_length=5, null=True)),
                ('package_version', models.IntegerField(blank=True, db_index=True, help_text='Version number of tigatrapp package from which this report was submitted.', null=True)),
                ('history_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField()),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to='tigaserver_app.TigaUser')),
                ('bite_count', models.PositiveSmallIntegerField(blank=True, help_text='Total number of bites reported.', null=True)),
                ('breeding_site_has_larvae', models.BooleanField(blank=True, help_text='Either if the user perceived larvaes the breeding site.', null=True)),
                ('breeding_site_has_near_mosquitoes', models.BooleanField(blank=True, help_text='Either if the user perceived mosquitoes near the breeding site (less than 10 meters).', null=True)),
                ('breeding_site_has_water', models.BooleanField(blank=True, help_text='Either if the user perceived water in the breeding site.', null=True)),
                ('breeding_site_in_public_area', models.BooleanField(blank=True, help_text='Either if the breeding site is found in a public area.', null=True)),
                ('breeding_site_type', models.CharField(blank=True, choices=[('basin', 'Basin'), ('bucket', 'Bucket'), ('fountain', 'Fountain'), ('small_container', 'Small container'), ('storm_drain', 'Storm Drain'), ('well', 'Well'), ('other', 'Other')], help_text='Breedign site tpye.', max_length=32, null=True)),
                ('chest_bite_count', models.PositiveSmallIntegerField(blank=True, help_text='Number of bites reported in the chest.', null=True)),
                ('datetime_fix_offset', models.IntegerField(blank=True, default=None, editable=False, help_text="An integer representing the offset (in seconds) applied to the original datetime values for fixing. If None, it indicates that no information about the original time zone could be inferred or the timezone was already provided when posting the report. To retrieve the original values, use: original_value = current_value - datetime_fix_offset.Fields to apply (if necessary) are: 'phone_upload_time', 'creation_time' and 'version_time'.", null=True)),
                ('event_environment', models.CharField(blank=True, choices=[('indoors', 'Indoors'), ('outdoors', 'Outdoors'), ('vehicle', 'Inside vehicle')], help_text='The environment where the event took place.', max_length=16, null=True)),
                ('event_moment', models.CharField(blank=True, choices=[('now', 'Now'), ('last_morning', 'Last morning'), ('last_midday', 'Last midday'), ('last_afternoon', 'Last afternoon'), ('last_night', 'Last night')], help_text='The moment of the day when the event took place.', max_length=32, null=True)),
                ('head_bite_count', models.PositiveSmallIntegerField(blank=True, help_text='Number of bites reported in the head.', null=True)),
                ('left_arm_bite_count', models.PositiveSmallIntegerField(blank=True, help_text='Number of bites reported in the left arm.', null=True)),
                ('left_leg_bite_count', models.PositiveSmallIntegerField(blank=True, help_text='Number of bites reported in the left leg.', null=True)),
                ('right_arm_bite_count', models.PositiveSmallIntegerField(blank=True, help_text='Number of bites reported in the right arm.', null=True)),
                ('right_leg_bite_count', models.PositiveSmallIntegerField(blank=True, help_text='Number of bites reported in the right leg.', null=True)),
                ('user_perceived_mosquito_abdomen', models.CharField(blank=True, choices=[('albopictus', 'Aedes albopictus'), ('aegypti', 'Aedes aegypti'), ('japonicus', 'Aedes japonicus'), ('koreicus', 'Aedes koreicus'), ('culex', 'Culex pipiens'), ('other', 'Other')], help_text='The species of mosquito that the abdomen resembles, according to the user.', max_length=16, null=True)),
                ('user_perceived_mosquito_legs', models.CharField(blank=True, choices=[('albopictus', 'Aedes albopictus'), ('aegypti', 'Aedes aegypti'), ('japonicus', 'Aedes japonicus'), ('koreicus', 'Aedes koreicus'), ('culex', 'Culex pipiens'), ('other', 'Other')], help_text='The species of mosquito that the leg resembles, according to the user.', max_length=16, null=True)),
                ('user_perceived_mosquito_specie', models.CharField(blank=True, choices=[('albopictus', 'Aedes albopictus'), ('aegypti', 'Aedes aegypti'), ('japonicus', 'Aedes japonicus'), ('koreicus', 'Aedes koreicus'), ('culex', 'Culex pipiens'), ('other', 'Other')], help_text='The mosquito specie perceived by the user.', max_length=16, null=True)),
                ('user_perceived_mosquito_thorax', models.CharField(blank=True, choices=[('albopictus', 'Aedes albopictus'), ('aegypti', 'Aedes aegypti'), ('japonicus', 'Aedes japonicus'), ('koreicus', 'Aedes koreicus'), ('culex', 'Culex pipiens'), ('other', 'Other')], help_text='The species of mosquito that the thorax resembles, according to the user.', max_length=16, null=True)),
            ],
            options={
                'verbose_name': 'historical report',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': 'history_date',
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.RunPython(populate_report_history_table),
    ]
